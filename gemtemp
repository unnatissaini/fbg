

// --- Communication & Control Constants ---
int const iDATALEN = 4;
int const iCHANELS = 4;
int const iReadThresoldCom = iDATALEN * iCHANELS + 2;
char const cStopCom = 'S';
char const cAcqCom = 'G';
char const cLinkCom = 'L';
char bComChar;
boolean bIsLinked = false;
boolean bIsInAcqMode = false;
unsigned long const lKillTime = 100;
const int iBaudRate = 115200;
int iReadStatus;
int tcount = 0;
int ChA = 0, ChB = 0, ChC = 0, ChD = 0;
int AvgChA = 0, AvgChB = 0, AvgChC = 0, AvgChD = 0;
volatile bool shouldPrint = false; // Flag to indicate whether data should be printed
volatile int dataToPrint[4] = {0};
// --- Pin Definitions ---
const int EN1 = 25;
const int PinG = 9;
const int SEROP = 14;
const byte interruptPin = 4;

// --- Delay Setting (Values to be written to PIOC) ---
byte DelayByt1 = 0x38;
byte DelayByt2 = 0x6D;
byte DelayByt3 = 0xA7;
byte DelayByt4 = 0xE3;

// --- Data Buffers and Flags (volatile for ISR access) ---
const int MAX_COUNT = 256;
volatile uint16_t i = 0;
volatile int signalBuffer[MAX_COUNT];
volatile bool sampleRequest = false;
volatile uint16_t lastSampleIndex = 0;
volatile bool fullWaveReady = false;

// --- Peak Storage ---
int peakIndices[MAX_COUNT];
int peakValues[MAX_COUNT];
int peakCount = 0;


// --- Function Prototypes ---
void setChHwAddress(int iChNo);
void setDelayByteL(int iDelayL);
void setDelayByteH(int iDelayH);
String getCommandResponse(char cUseComChar);
String FormatDataToFixLen(int iNumber);
void startTimer(Tc *tc, uint32_t channel, IRQn_Type irq, uint32_t frequency);
void GetCommand();
void blink();
void findPeaks(const int data[MAX_COUNT]);
void displayPeaks();


// --- Setup Function ---
void setup() {
    Serial.begin(iBaudRate);
    delay(10);

    // Pin configuration
    PIOC->PIO_PER = 0x01FE; // Configure PORTC for PIO control
    PIOC->PIO_OER = 0x01FE; // Set PORTC pins as outputs
    PIOD->PIO_PER = 0x01FF; // Configure PORTD for PIO control
    PIOD->PIO_OER = 0xFFFF; // Set PORTD pins as outputs
    pinMode(EN1, OUTPUT);
    pinMode(PinG, OUTPUT);
    pinMode(SEROP, OUTPUT);
    analogReadResolution(12);
    pinMode(interruptPin, INPUT_PULLUP);
    
    // Initial pin state and interrupt setup
    PIOC->PIO_ODSR = ((DelayByt1) * 2);
    digitalWrite(EN1, HIGH);
    digitalWrite(EN1, LOW);
    attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);
    startTimer(TC1, 0, TC3_IRQn, 100);
}


// --- Main Program Loop ---
void loop() {
    GetCommand();

    // Handle pending sample requests from the ISR
    if (sampleRequest) {
        // Make a local copy of the index to work with
        noInterrupts();
        uint16_t idx = lastSampleIndex;
        sampleRequest = false;
        interrupts();

        // Perform the analog read and store it in the buffer
        int val = analogRead(4);
        signalBuffer[idx] = val;

        // Perform pin manipulations outside the ISR
        digitalWrite(PinG, HIGH);
        delayMicroseconds(5);
        digitalWrite(PinG, LOW);
        
        PIOC->PIO_ODSR = ((uint32_t)idx * 2);
        
        digitalWrite(EN1, HIGH);
        delayMicroseconds(5);
        digitalWrite(EN1, LOW);
    }
    
    // Process a full wave when it is ready
    if (fullWaveReady) {
        int localSignal[MAX_COUNT];
        
        // Atomically copy the volatile buffer to a local, stable array
        noInterrupts();
        for (int k = 0; k < MAX_COUNT; ++k) localSignal[k] = signalBuffer[k];
        fullWaveReady = false;
        interrupts();

        // Analyze the local copy for peaks and then display them
        findPeaks(localSignal);
        displayPeaks();
    }
}


// --- Interrupt Service Routine ---
void blink() {
    // Set the flag for the main loop to process the sample
    lastSampleIndex = i;
    sampleRequest = true;

    // Increment index and check for wrap-around
    if (++i >= MAX_COUNT) {
        i = 0;
        fullWaveReady = true;
    }
}


// --- Peak Finding Function (Modified) ---
void findPeaks(const int data[MAX_COUNT]) {
    peakCount = 0;
    const int THRESHOLD = 200; // Define a threshold for peak detection
    
    // Iterate through the data, manually adjusting the index 'k'
    for (int k = 1; k < MAX_COUNT - 1; ++k) {
        int prev = data[k - 1];
        int curr = data[k];
        int next = data[k + 1];

        // Step 1: Find a local maximum that is also above the threshold
        if (curr > prev && curr > next && curr > THRESHOLD) {
            // Step 2: Compare with the next 10 values to confirm it's a prominent peak
            bool isProminent = true;
            int endCheck = min(k + 10, MAX_COUNT);
            for (int j = k + 1; j < endCheck; ++j) {
                if (data[j] >= curr) {
                    isProminent = false;
                    break;
                }
            }

            // If it's a prominent peak, store it
            if (isProminent) {
                peakIndices[peakCount] = k;
                peakValues[peakCount] = curr;
                peakCount++;
            }
            
            // Step 3: Skip the next 5 indices to avoid finding peaks too close together
            // The for loop's ++k will increment it one more time.
            k += 5;
        }
    }
}


// --- New Function to Display Peak Data ---
void displayPeaks() {
    Serial.println("\n--- Peak Analysis Results ---");
    Serial.print("Total Peaks Found: ");
    Serial.println(peakCount);
    
    if (peakCount > 0) {
        Serial.println("-----------------------------");
        Serial.println("Index\tValue");
        Serial.println("-----------------------------");
        for (int j = 0; j < peakCount; j++) {
            Serial.print(peakIndices[j]);
            Serial.print("\t");
            Serial.println(peakValues[j]);
        }
        Serial.println("-----------------------------");
    }
}


// --- All Other Functions (your original) ---
void setChHwAddress(int iChNo) {
    PIOC->PIO_ODSR = 0x03FE;
}

void setDelayByteL(int iDelayL) {
    PIOC->PIO_ODSR = iDelayL & 0x03FE;
}

void setDelayByteH(int iDelayH) {
    PIOC->PIO_ODSR = iDelayH & 0x03FE;
}

String getCommandResponse(char cUseComChar) {
    String strResponse = "[";
    for (int k = 0; k < (iReadThresoldCom - 2); k++)
        strResponse += cUseComChar;
    strResponse += "]";
    return strResponse;
}

String FormatDataToFixLen(int iNumber) {
    String strRet = String(iNumber);
    int j = iDATALEN - strRet.length();
    for (int k = 0; k < j; k++) {
        strRet = "0" + strRet;
    }
    return strRet;
}

void TC3_Handler() {
    TC_GetStatus(TC1, 0);
    tcount++;
    if (bIsInAcqMode) {
        dataToPrint[0] = AvgChA;
        dataToPrint[1] = AvgChB;
        dataToPrint[2] = AvgChC;
        dataToPrint[3] = AvgChD;
        shouldPrint = true;
    }
    tcount++;
    if (tcount == 1) {
        ChD = 0;
        AvgChA = 0;
        tcount = 0;
    }
}

void startTimer(Tc *tc, uint32_t channel, IRQn_Type irq, uint32_t frequency) {
    pmc_set_writeprotect(false);
    pmc_enable_periph_clk((uint32_t)irq);
    TC_Configure(tc, channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | TC_CMR_TCCLKS_TIMER_CLOCK4);
    uint32_t rc = VARIANT_MCK / 128 / frequency;
    TC_SetRA(tc, channel, rc / 2);
    TC_SetRC(tc, channel, rc);
    TC_Start(tc, channel);
    tc->TC_CHANNEL[channel].TC_IER = TC_IER_CPCS;
    tc->TC_CHANNEL[channel].TC_IDR = ~TC_IER_CPCS;
    NVIC_EnableIRQ(irq);
}

void GetCommand() {
    if (Serial.available() > 0) {
        iReadStatus = Serial.readBytes(&bComChar, 1);
        Serial.flush();
        switch (bComChar) {
            case cLinkCom:
                delay(lKillTime);
                Serial.println(getCommandResponse(cLinkCom));
                bIsLinked = true;
                bIsInAcqMode = false;
                break;
            case cAcqCom:
                Serial.println(getCommandResponse(cAcqCom));
                bIsInAcqMode = true;
                delay(lKillTime);
                break;
            case cStopCom:
                Serial.println(getCommandResponse(cStopCom));
                bIsInAcqMode = false;
                delay(lKillTime);
                break;
        }
    }
}
