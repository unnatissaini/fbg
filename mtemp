int const iDATALEN = 4;                // Average reading is 4 bytes
int const iCHANELS = 4;                // Four channels
int const iReadThresoldCom = iDATALEN * iCHANELS + 2; // +2 for [ & ] chars
char const cStopCom = 'S';             // Stop command
char const cAcqCom = 'G';              // Acquire command
char const cLinkCom = 'L';             // Link command, acquire at 10 Hz
char bComChar;                         // Command Char
boolean bIsLinked = false;             // Linked status
boolean bIsInAcqMode = false;          // Acquisition mode
unsigned long const lKillTime = 100;   // General delay in ms
const int iBaudRate = 115200;          // Higher baud rate
int iReadStatus;
int tcount = 0;
int ChA = 0, ChB = 0, ChC = 0, ChD = 0;
int AvgChA = 0, AvgChB = 0, AvgChC = 0, AvgChD = 0;

// Pin Definitions
const int EN1 = 25;
const int PinG = 9;
const int SEROP = 14;
const byte interruptPin = 4;

// Delay Setting----------------------
byte DelayByt1 = 0x38; // max at 185//1F
byte DelayByt2 = 0x6D; // max at 385 //47
byte DelayByt3 = 0xA7; // 6F
byte DelayByt4 = 0xE3; // 97
//------------------------------------
const int MAX_COUNT = 256;
volatile bool shouldPrint = false; // Flag to indicate whether data should be printed
volatile int dataToPrint[4] = {0}; // Array to store data for printing

void setChHwAddress(int iChNo) {
    PIOC->PIO_ODSR = 0x03FE; // Write something on pins 33-40
}

void setDelayByteL(int iDelayL) {
    PIOC->PIO_ODSR = iDelayL & 0x03FE; // Write delay ByteL something on pins 33-40
}

void setDelayByteH(int iDelayH) {
    PIOC->PIO_ODSR = iDelayH & 0x03FE; // Write delay ByteH something on pins 33-40
}

String getCommandResponse(char cUseComChar) {
    String strResponse = "["; 
    for (int i = 0; i < (iReadThresoldCom - 2); i++)
        strResponse += cUseComChar;
    strResponse += "]";
    return strResponse;
}

String FormatDataToFixLen(int iNumber) {
    String strRet = String(iNumber);
    int j = iDATALEN - strRet.length();
    for (int i = 0; i < j; i++) {
        strRet = "0" + strRet;
    }
    return strRet;
}

void TC3_Handler() {
    TC_GetStatus(TC1, 0); // Clear interrupt flag
    tcount++;

    if (bIsInAcqMode) {
        // Minimized processing in ISR: Storing the data directly into a volatile array
        dataToPrint[0] = AvgChA;
        dataToPrint[1] = AvgChB;
        dataToPrint[2] = AvgChC;
        dataToPrint[3] = AvgChD;

        shouldPrint = true; // Set flag to print in the main loop
    }

    tcount++;
    if (tcount == 1) {
        // Reset after each acquisition cycle
        ChD = 0;
        AvgChA = 0;
        tcount = 0;
    }
}

void startTimer(Tc *tc, uint32_t channel, IRQn_Type irq, uint32_t frequency) {
    pmc_set_writeprotect(false);
    pmc_enable_periph_clk((uint32_t)irq);
    TC_Configure(tc, channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | TC_CMR_TCCLKS_TIMER_CLOCK4);
    uint32_t rc = VARIANT_MCK / 128 / frequency; // 128 because we selected TIMER_CLOCK4 above
    TC_SetRA(tc, channel, rc / 2); // 50% high, 50% low
    TC_SetRC(tc, channel, rc);
    TC_Start(tc, channel);
    tc->TC_CHANNEL[channel].TC_IER = TC_IER_CPCS;
    tc->TC_CHANNEL[channel].TC_IDR = ~TC_IER_CPCS;
    NVIC_EnableIRQ(irq);
}

void setup() {
    Serial.begin(iBaudRate); // Higher baud rate (250,000)
    delay(10);

    PIOC->PIO_PER = 0x01FE; // Configure PORTC to PIO controller, pins 33-40 C8-C1
    PIOC->PIO_OER = 0x01FE; // Enable PORTC to output

    PIOD->PIO_PER = 0x01FF; // Configure PORTD to PIO controller, pins 33-40
    PIOD->PIO_OER = 0xFFFF; // Enable PORTC to output

    pinMode(EN1, OUTPUT);
    pinMode(PinG, OUTPUT);
    pinMode(SEROP, OUTPUT);
    analogReadResolution(12);
    pinMode(interruptPin, INPUT_PULLUP);
    PIOC->PIO_ODSR = ((DelayByt1) * 2);
    digitalWrite(EN1, HIGH);
    digitalWrite(EN1, LOW);
    attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);
    startTimer(TC1, 0, TC3_IRQn, 100); // to initialize timer
}

void GetCommand() {
    if (Serial.available() > 0) { // Check for valid command
        iReadStatus = Serial.readBytes(&bComChar, 1); // read the incoming Char
        Serial.flush();

        switch (bComChar) {
        case cLinkCom:
            delay(lKillTime);
            Serial.println(getCommandResponse(cLinkCom));
            bIsLinked = true;
            bIsInAcqMode = false;
            break;

        case cAcqCom:
            Serial.println(getCommandResponse(cAcqCom));
            bIsInAcqMode = true;
            delay(lKillTime);
            break;

        case cStopCom:
            Serial.println(getCommandResponse(cStopCom));
            bIsInAcqMode = false;
            delay(lKillTime);
            break;
        }
    }
}
 volatile byte i = 0x00;

void loop() {
    GetCommand();
    if (Serial.availableForWrite() > 0) {
        Serial.print(i); // Print the value of 'i' outside of the ISR
        Serial.print("- ");
        Serial.println(ChA);
    }
   /* if (shouldPrint) {
        String strData = "[" + FormatDataToFixLen(dataToPrint[0]) + 
                          FormatDataToFixLen(dataToPrint[1]) + 
                          FormatDataToFixLen(dataToPrint[2]) + 
                          FormatDataToFixLen(dataToPrint[3]) + "]";
        if (Serial.availableForWrite()) {
            //Serial.println(strData); // Only print if serial is ready
        }
        shouldPrint = false; // Reset flag
    }
*/

}


void blink() {
    ChA = analogRead(4); // Read analog sample
   // byte delay= ((byte)i*2);
    digitalWrite(PinG, HIGH);
    delayMicroseconds(5);
    digitalWrite(PinG, LOW);
    PIOC->PIO_ODSR = (i*2);
    digitalWrite(EN1, HIGH);
    delayMicroseconds(5);
    digitalWrite(EN1, LOW);
    i++;  // Increment i for next loop iteration


  if (i >= MAX_COUNT) {
    detachInterrupt(digitalPinToInterrupt(interruptPin));
  }
}
