//updated list with new task
//21aug
      int const iDATALEN = 4;                 // average reading is 4 bytes (after making nibbles)
      int const iCHANELS = 4;                 // Six chanels
      int const iReadThresoldCom = iDATALEN * iCHANELS + 2;    // +2 for [ & ] chars
      char const cStopCom = 'S';              //Stop command
      char const cAcqCom  = 'G';              //Acquire command
      char const cLinkCom = 'L';              //Link command, acquire at 10 Hz
      char bComChar;                    //Command Char
      boolean bIsLinked = false;        //Indicates linked status
      boolean bIsInAcqMode = false;     //Indicates acqusition mode
      String strData;
      unsigned long const lKillTime = 100;    //General delay in ms, wantssampling at 10 Hzs
      const int iBaudRate = 38400;            //To ensure data safety operate at optimum speed
      int iReadStatus;
      //const int iComLength = 13;               //Change this if size of command changes
      int tcount=0;
      const byte interruptPin = 4;
// delay setting----------------------
byte DelayByt1=0x00;// max at 185//1F                     //Hold Delay Byte high
byte DelayByt2=0x00;// max at 385 //47                      //Hold Delay Byte high
byte DelayByt3=0x00;      //6F                 //Hold Delay Byte high
byte DelayByt4=0x00;       //97                //Hold Delay Byte high
//------------------------------------
int  iChNo=0;
int  iCountNo=0;
int  PrintData;
//short iaDelayData[48];                //Storing incoming delay Data on 29-03-2024
int AvgBy = 20;
int ChA=0;
int ChB=0;
int ChC=0;
int ChD=0;
int AvgChA=0;
int AVgChB=0;
int AvgChC=0;
int AvgChD=0;
//---------------------------------Pin Defination
const int EN1 = 25;
const int PinG = 9;
const int SEROP = 14;
int value[256];     // Simulated signal values
int peaks[256];      
int peakCount = 0;




// ---- NEW: calibration config ----
#define SIG_LEN   256
#define NUM_RUNS  8

// ---- NEW: calibration storage & state ----
volatile uint16_t signalData[NUM_RUNS][SIG_LEN]; // 8 signals × 256 samples
volatile uint8_t  gSigNo = 0;                    // which signal [0..7]
volatile uint16_t gSampleIdx = 0;                // sample index [0..255]
volatile bool     gCalibBlockDone = false;       // set true when 8×256 captured
volatile bool     gCalibrationDone = false;      // set true after peaks detected

// ---- NEW: averaged waveform (int so math is comfy) ----
int avgSignal[SIG_LEN];




void setChHwAddress(int iChNo)
{
    PIOC->PIO_ODSR = 0x03FE; // Write something on pins 33-40
    }
//-----------------
void setDelayByteL(int iDelayL)
{
    PIOC->PIO_ODSR = iDelayL & 0x03FE; // Write delay ByleL something on pins 33-40
    }
//---------------------
void setDelayByteH(int iDelayH)
{
    PIOC->PIO_ODSR = iDelayH & 0x03FE; // Write delay ByleH something on pins 33-40
   }
//for scanning-------------
// REPLACE your detectPeaks() with this:
void detectPeaksOn(const int* data, int len, int* outPeaks, int* outCount, int threshold) {
  int count = 0;
  int i = 1;
  while (i < len - 1) {
    if (data[i] >= threshold) {
      int peakIndex = i;
      Serial.print(data[i]);
      int peakValue = data[i];
      while (i < len - 1 && data[i] >= threshold) {
        if (data[i] > peakValue) {
          peakValue = data[i];
          peakIndex = i;
        }
        i++;
      }
      if (count < 4) {            // <= we only need first FOUR peaks
        outPeaks[count++] = peakIndex;
        i += 10;   // your original skip
              for( int i=0 ; i< peakCount;i++)
  {  Serial.print(peakIndex);}
      }
    } else {
      i++;
    }

  }
  *outCount = count;

}
// ---- NEW: average 8 signals into avgSignal[256] ----
void computeAvgSignal() {
  for (int i = 0; i < SIG_LEN; i++) {
    long sum = 0;
    for (int s = 0; s < NUM_RUNS; s++) sum += signalData[s][i];
    avgSignal[i] = (int)(sum / NUM_RUNS);  // integer average
  }
}
// ---- NEW: calibration ISR: capture samples into signalData ----
void calibISR() {
  uint16_t v = analogRead(4);                    // your current ADC channel
  signalData[gSigNo][gSampleIdx++] = v;

  if (gSampleIdx >= SIG_LEN) {                   // finished one signal
    gSampleIdx = 0;
    gSigNo++;

    // (Your hardware provides the ~5 ns separation between signals.)

    if (gSigNo >= NUM_RUNS) {                    // finished all 8 signals
      gSigNo = 0;
      gCalibBlockDone = true;                    // let loop() process
      detachInterrupt(digitalPinToInterrupt(interruptPin)); // stop capture
    }
  }
}
// ---- NEW: run once after capture ----
void finalizeCalibration() {
  // 1) Average 8 signals
  computeAvgSignal();

  // 2) Detect up to 4 peaks on the averaged waveform
  peakCount = 0;
  detectPeaksOn(avgSignal, SIG_LEN, peaks, &peakCount, 20 /*threshold*/);

  // 3) Ensure we have 4 entries (pad by repeating last found or zero)
  if (peakCount == 0) { peaks[0]=peaks[1]=peaks[2]=peaks[3]=0; peakCount=4; }
  else {
    for (int i = peakCount; i < 4; i++) peaks[i] = peaks[peakCount-1];
    peakCount = 4;
  }

  // 4) Switch the interrupt to your runtime ISR
  attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);

  gCalibrationDone = true;


//  Serial.print("Peak index: ");

//  Serial.print("  Peak value: ");
//  Serial.print(peakValue);       // decimal
//  Serial.print(" (0x");
//  Serial.print(peakValue, HEX);  // hex
//  Serial.println(")");

}


//--------------------------------

String getCommandResponse(char cUseComChar)
  {
      String strResponse = "[";
      for (int i = 0; i < (iReadThresoldCom - 2); i++)
       strResponse += cUseComChar;

      strResponse += "]";
      return strResponse;
  }
//----------------------------------
String FormatDataToFixLen(int iNumber)
{   int i, j;
    String strRet;
      strRet = String(iNumber);
      j = iDATALEN - strRet.length();
      for (i = 0; i < j; i++)
       {
        strRet = "0" + strRet;
       }
      return strRet;
}        
//---------------------------
void TC3_Handler()
{
    TC_GetStatus(TC1, 0);
    tcount++;
    if(bIsInAcqMode)//((D)>53 & (E)>348)
    {
    String strData = "[" + FormatDataToFixLen(AvgChA) + FormatDataToFixLen(AVgChB) + FormatDataToFixLen(AvgChC) + FormatDataToFixLen(AvgChD) + "]";
    //String strData =  FormatDataToFixLen(E) + "," + FormatDataToFixLen(F) + "," + FormatDataToFixLen(H) + "," + FormatDataToFixLen(I);
    Serial.println(strData);
    }
    tcount++;

    if(tcount == 1) 
    {
      //A=0;
      //B=0;
      ChD=0;
      AvgChA = 0;
      tcount = 0;
    }
    //A=0;
    //B=0;
    ChD = 0;
    AvgChA = 0;
}
void startTimer(Tc *tc, uint32_t channel, IRQn_Type irq, uint32_t frequency) 
{
    pmc_set_writeprotect(false);
    pmc_enable_periph_clk((uint32_t)irq);
    TC_Configure(tc, channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | TC_CMR_TCCLKS_TIMER_CLOCK4);
    uint32_t rc = VARIANT_MCK/128/frequency; //128 because we selected TIMER_CLOCK4 above
    TC_SetRA(tc, channel, rc/2); //50% high, 50% low
    TC_SetRC(tc, channel, rc);
    TC_Start(tc, channel);
    tc->TC_CHANNEL[channel].TC_IER=TC_IER_CPCS;
    tc->TC_CHANNEL[channel].TC_IDR=~TC_IER_CPCS;
    NVIC_EnableIRQ(irq);
}

void setup()
{
    // put your setup code here, to run once:
    Serial.begin(iBaudRate);
    delay(10);

    PIOC->PIO_PER = 0x01FE; // Configure PORTC to PIO controller, pins 33-40 C8-C1
    PIOC->PIO_OER = 0x01FE; // Enable PORTC to output

    PIOD->PIO_PER = 0x01FF; // Configure PORTD to PIO controller, pins 33-40
    PIOD->PIO_OER = 0xFFFF; // Enable PORTC to output

    //PIOC->PIO_ODSR = 0x0100; // Write something on pins 33-40
    //PIOD->PIO_ODSR = 0x00;

    //All strobes in OUTPUT mode
    pinMode(EN1, OUTPUT);
    pinMode(PinG, OUTPUT);
    pinMode(SEROP,OUTPUT);
    analogReadResolution(12);
    pinMode(interruptPin, INPUT_PULLUP);
    PIOC->PIO_ODSR = ((DelayByt1)* 2) ;
          
    digitalWrite(EN1, HIGH);
    digitalWrite(EN1, LOW);

    // In setup(), REPLACE your attachInterrupt(..., blink, RISING) with:
    attachInterrupt(digitalPinToInterrupt(interruptPin), calibISR, RISING);

  startTimer(TC1, 0, TC3_IRQn, 100);// to initilize timer
//for scanning--------------------------------------------------------------------------------------------------
}
//All serial responses are sent to PC by this subroutine, you need to change here only
void GetCommand()
{
    if (Serial.available() > 0) //Check for valid command
    {  
      iReadStatus = Serial.readBytes(&bComChar, 1);    // read the incoming Char
      Serial.flush();                                  
        
      switch (bComChar) 
      { 
      case cLinkCom : 
      delay(lKillTime);
      Serial.println(getCommandResponse(cLinkCom)); 
      bIsLinked = true;
      bIsInAcqMode = false;
      break;

      case cAcqCom :
      Serial.println(getCommandResponse(cAcqCom)); 
      bIsInAcqMode = true;
      delay(lKillTime);
      break;

      case cStopCom :
      Serial.println(getCommandResponse(cStopCom)); 
      bIsInAcqMode = false;
      delay(lKillTime);
      break;
    }      //end of switch
  }
}

void loop()
{
  GetCommand();
  // In loop(), ADD:
  if (!gCalibrationDone && gCalibBlockDone) {
    finalizeCalibration();
    gCalibBlockDone = false; // not strictly needed once detached
  }
  
  }


void blink() 
{
    iChNo++;
    iCountNo++;
        
        if (iChNo == 1) 
        {
          delayMicroseconds(6);
          ChA+=analogRead(4);
          delayMicroseconds(0.5);
          ChA+=analogRead(4);
          delayMicroseconds(0.5);
          ChA+=analogRead(4);
          delayMicroseconds(0.5);
          ChA+=analogRead(4);
          
          delayMicroseconds(6);
          digitalWrite(PinG, HIGH);
          delayMicroseconds(20);
          digitalWrite(PinG, LOW);
          PIOC->PIO_ODSR = ((peaks[1])* 2) ;
          
          digitalWrite(EN1, HIGH);
          digitalWrite(EN1, LOW);
          if(iCountNo==17)//37
          {
            AvgChA=ChA/20;
            ChA=0;
          }
        }
        
        if (iChNo==2) 
        {
          delayMicroseconds(6);
          ChB+=analogRead(4);
          delayMicroseconds(0.5);
          ChB+=analogRead(4);
          delayMicroseconds(0.5);
          ChB+=analogRead(4);
          delayMicroseconds(0.5);
          ChB+=analogRead(4);
          
          delayMicroseconds(6);
          digitalWrite(PinG, HIGH);
          delayMicroseconds(20);
          digitalWrite(PinG, LOW);
          PIOC->PIO_ODSR = ((peaks[2])* 2);
          digitalWrite(EN1, HIGH);
          digitalWrite(EN1, LOW);
          if(iCountNo==18)//38
          {
            AVgChB=ChB/20;//40
            ChB=0;
          }
        }

       if (iChNo==3) 
       {
          delayMicroseconds(6);
          ChC+=analogRead(4);
          delayMicroseconds(0.5);
          ChC+=analogRead(4);
          delayMicroseconds(0.5);
          ChC+=analogRead(4);
          delayMicroseconds(0.5);
          ChC+=analogRead(4);
          
          delayMicroseconds(6);
          digitalWrite(PinG, HIGH);
          delayMicroseconds(20);
          digitalWrite(PinG, LOW);
          PIOC->PIO_ODSR = ((peaks[3])* 2) ;
          
          digitalWrite(EN1, HIGH);
          digitalWrite(EN1, LOW);
          if(iCountNo==19)//39
          {
            AvgChC=ChC/20;
            ChC=0;
          }
        }
        
        if (iChNo==4) 
        {
          delayMicroseconds(6);
          ChD+=analogRead(4);
          delayMicroseconds(0.5);
          ChD+=analogRead(4);
          delayMicroseconds(0.5);
          ChD+=analogRead(4);
          delayMicroseconds(0.5);
          ChD+=analogRead(4);
          
          delayMicroseconds(6);
          digitalWrite(PinG, HIGH);
          delayMicroseconds(20);
          digitalWrite(PinG, LOW);
          PIOC->PIO_ODSR = ((peaks[0])* 2);
          digitalWrite(EN1, HIGH);
          digitalWrite(EN1, LOW);
          if(iCountNo==20)//40
          {
            AvgChD=ChD/20;
            iCountNo=0;
            ChD=0;
          }
        iChNo=0;
        }
}
